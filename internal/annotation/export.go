package annotation

import (
	"fmt"
	"os"
	"strings"
	"text/template"

	"github.com/go-chocolate/chocdoc/version"
)

const (
	templateText = `// Code generated by chocdoc. DO NOT EDIT.
// version: {{.version}}

package {{.package}}

import(
    "github.com/go-chocolate/chocdoc/elements"
{{.imports}})

var nodes = map[string]*elements.Node{
{{.nodes}}
}

func Nodes() map[string]*elements.Node {
	return nodes
}

`

	dotAnnotationFile    = ".godoc"
	dotAnnotationContent = "# 本目录由godoc自动生成，请勿修改/添加/移动本目录内任何文件"
)

var tpl, _ = template.New("annotation").Parse(templateText)

func export(opt *option) error {
	d := &decoder{
		root:     opt.Root,
		replaces: opt.Replaces,
	}

	files, err := d.decode()
	if err != nil {
		return err
	}

	os.MkdirAll(opt.Output, 0777)
	os.WriteFile(fmt.Sprintf("%s/%s", opt.Output, dotAnnotationFile), []byte(dotAnnotationContent), 0644)

	var pkg = opt.Output
	if n := strings.LastIndex(opt.Output, "/"); n > 0 {
		pkg = opt.Output[n+1:]
	}

	var body []string
	var imports = map[string]struct{}{}
	for _, v := range files {
		for _, n := range v.nodes {
			if !n.exported || len(n.annotations) == 0 {
				continue
			}
			format, imps := n.format()
			for _, im := range imps {
				imports[im] = struct{}{}
			}
			body = append(body, fmt.Sprintf("    \"%s\": ", n.path)+format)
		}
	}

	value := map[string]string{
		"package": pkg,
		"version": version.VERSION,
		"nodes":   strings.Join(body, ",\n") + ",",
		"imports": "\n",
	}
	for imp := range imports {
		value["imports"] = value["imports"] + fmt.Sprintf("    \"%s\"\n", imp)
	}

	filename := fmt.Sprintf("%s/annotation.go", opt.Output)
	output, err := os.OpenFile(filename, os.O_CREATE|os.O_RDWR, 0644)
	if err != nil {
		return err
	}
	defer output.Close()
	return tpl.Execute(output, value)
}

type ExportOption func(o *option)

func WithDotAnnotationFile() ExportOption {
	return func(o *option) {
		if opt, err := fromOptionFile(); err == nil {
			o.from(opt)
		}
	}
}

func WithSaveDotAnnotationFile() ExportOption {
	return func(o *option) {
		o.save = true
	}
}
func WithRoot(root string) ExportOption {
	return func(o *option) {
		o.Root = root
	}
}
func WithOutput(output string) ExportOption {
	return func(o *option) {
		o.Output = output
	}
}
func WithReplaces(path string, alias string) ExportOption {
	return func(o *option) {
		if o.Replaces == nil {
			o.Replaces = make(map[string][]string)
		}
		o.Replaces[path] = append(o.Replaces[path], alias)
	}
}

func applyExportOptions(options ...ExportOption) *option {
	opt := &option{Replaces: make(map[string][]string)}
	for _, o := range options {
		o(opt)
	}
	return opt
}

func Export(options ...ExportOption) error {
	opt := applyExportOptions(options...)
	if opt.save {
		defer opt.saveToFile()
	}
	return export(opt)
}
